# .java文件编译成.class文件，在jvm中运行

## .java源文件

## .class字节码文件







# JDK

## java开发工具包，jdk = jre + java开发工具（java，javac，javadoc，javap等）

# jre 

## java运行时环境 jre = jvm + java核心类库



# 编写程序

```java
public class HelloTest {

	public static void main(String[] args) {

		System.out.println("蔬菜精灵 is studying java!");
	}
}
```

以gbk格式保存

在文件路径下打开控制台

javac 将.java文件编译成.class

java命令运行程序，注意：运行时去掉.class否则报错

![image-20220903201451234](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220903201451234.png)

## 编译后，每一个类都会生成一个.class字节码文件

## public共有类，文件名与类名必须一致

## 一个.java源文件中只能有一个public类，其他类的个数不限个数，也可以将main方法写在非public类中



# 转义符

```java
//转义符
public class ChangeChar {

	public static void main(String[] args) {
		
		// \t ： 一个制表位，实现对齐的功能
		System.out.println("北京\t天津\t上海"); //北京    天津    上海
		// \n : 换行符
		System.out.println("北京\n天津\n上海");//北京
										     //天津
											 //上海
		// \\ ：输出一个\
		System.out.println("北京\\天津\\上海"); //北京\天津\上海
		// \\\\ ： 输出两个\\
		System.out.println("北京\\\\天津\\\\上海");//北京\\天津\\上海
		// \" ： 输出一个"
		System.out.println("\"北京\"\"天津\"\"上海\"");//"北京""天津""上海"
		// \' : 输出一个'
		System.out.println("\'北京\'\'天津\'\'上海\'");//'北京''天津''上海'
		// \r : 输出一个回车
		//回车会把光标移动到北京前面，后面输出的字符会覆盖掉前面的
		System.out.println("北京\r天津\r\n上海");//天津
											   //上海
	}
}
```



# java数据类型

## 基本数据类型

### 数值型

#### 整数类型，存放整数：byte[1]-> 一个字节, short[2], int[4],long[8]

#### 浮点型：float[4],double[8] ：浮点数 = 符号位+指数位+位数位

#### 字符型 : char[2] ,存放单个字符'a'

####  布尔型：boolean[1],存放true，false

##### 一个字节等于8个bit

## 引用数据类型

### 类 class

### 接口 interface

### 数组 []



# 基本类型转换

## 自动类型转换

### 1.char -> int -> long -> float -> double

### 2.byte -> short -> int -> long -> float -> double

### 3.byte ,short ,char 计算时会自动转换成int 

### 4. 表达式的结果类型会自动提升为操作数中最大的类型

## 强制类型转换

### 强制符号只针对最近的操作数有效，往往使用小括号提升优先级



# 基本数据类型和String类型的转换

## 1.基本类型转String类型： + ""即可

## 2.String类型转基本数据类型：通过基本数据类型的包装类调用parseXX方法即可

```java
public class StringToBasic {
	public static void main(String[] args) {
		String s1 = "123";
		String s2 = "123.1";
		String s3 = "123.123";
		String s4 = "true";
		String s5 = "12312312312312";

		
		int num1 = Integer.parseInt(s1);
		System.out.println(num1);   // 123
		
		float num2 = Float.parseFloat(s2);
		System.out.println(num2);   //123.1

		double num3 = Double.parseDouble(s3);
		System.out.println(num3);   //123.123

		boolean num4 = Boolean.parseBoolean(s4);
		System.out.println(num4);   // true

		long num5 = Long.parseLong(s5);
		System.out.println(num5);   //12312312312312
	}
}
```

## char相加，会先转换成对应的码值然后转换成整型

```java
public class CharPlus {
	public static void main(String[] args) {
		
		char c1 = '男';
		char c2 = '女';

		System.out.println(c1 + c2);  //52906

	}
}
```



# 运算符

```JAVA
double num = 10 / 4;
System.out.println(num); // 2.0 : 10/4 -> 2, 2->2.0
```

## !!!取模 a % b = a - a/b*b 

### 10 % 3 = 1 : 10 - 10 / 3 * 3 = 1

### -10 % 3 = -1 : -10 - (-10) /3 *3 = -1

### 10 %- 3 = 1 : 10 - 10 /(-3) *(-3) = 1

### -10 % -3 = -1 : -10 - (-10) /(-3 )*(-3 )= -1

## 当a为小数时 a % b = a - (int)a/b*b 

### -10.5%3 = -10.5 - (-10) /3 *3 = -1.5 (注意，计算出的结果是近似值)

## 逻辑运算符

### && 短路与 ，& 逻辑与 ：区别 ： 短路与  前面为false  后面不执行 ，逻辑与都执行

### ||短路或，|逻辑或 ：区别 ： 短路或 前面为true 后面不执行 都为true，效率高，逻辑或都执行

### 基本使用短路与 。短路

## 符合运算符会进行类型转换

```java
byte b = 3;
b += 2; // 等价 b = (byte)(b + 2)
b++; // 等价 b = (byte)(b + 1)
```



## 题目

```java

public class ArithmeticOperatorExercise01 {

	public static void main(String[] args) {
		
		int i = 1;
		i = i++;
		System.out.println(i); //1 : (1)temp = i //1,(2) i = i + 1,//2 (3) i = temp //1

		int j = 1;
		j = ++j;
		System.out.println(j); //2 : (1) j = j + 1 //2,(2)temp = j,//2 (3) j = temp //2
	}
}
```

# 进制

## 二进制转八进制： 每三位转成一个八进制位

```java
001 010 011 000 -> 1230
```

## 二进制转十六进制：每四位转成一个十六进制位

```java
1010 1011 0010 1001 -> 0xAB29
```

## 八进制转二进制：每位转成三位二进制 

```JAVA
1230 -> 001 010 011 000
```

## 十六进制转二进制：每位转成四位二进制 

```java
0xAB29 -> 1010 1011 0010 1001
```



# 原码、反码、补码 （重点）

## 1. 二进制的最高位是符号位 ：0 表示整数，1表示负数

## 2. 正数的原码，反码，补码都一样（三码合一）

## 3. 负数的反码 = 它的原码符号不变，其他位取反 （0->1,1->0）

## 4. 负数的补码 = 它的反码+1，负数的反码 = 负数的补码 - 1

## 5. 0的反码，补码都是0

## 6. java没有无符号数，换言之，java中的数都是有符号的

## 7.在计算机运算的时候，都是以补码的方式来运算

## 8. 当我们看运算结果的时候，要看他的原码（重点）

```java
//位运算

public class BitOperator {

	public static void main(String[] args) {
		//推导
		//1.先得到2的补码 ： 因为计算机运算是以补码的方式运算的（重点）
		//  2的原码 ： 00000000 00000000 00000000 00000010
		//  2的补码 ： 00000000 00000000 00000000 00000010  正数的原码，反码，补码都一样
		//2.得到3的补码
		//  3的原码 ： 00000000 00000000 00000000 00000011
		//  3的补码 ： 00000000 00000000 00000000 00000011
		//3. 2&3运算
		//            00000000 00000000 00000000 00000010
		//            00000000 00000000 00000000 00000011
		//            00000000 00000000 00000000 00000010 // 运算后的补码
		//3. 运算后的原码
		//            00000000 00000000 00000000 00000010
		System.out.println(2&3);//2

		//推导
		//1.先得到-2的补码
		//  -2的原码： 10000000 00000000 00000000 00000010
		//  -2的反码： 11111111 11111111 11111111 11111101 负数的反码：除符号位外取反
		//  -2的补码： 11111111 11111111 11111111 11111110 负数的补码：反码+1
		//2. ~-2运算
		//            00000000 00000000 00000000 00000001 运算后的补码
		//3. 运算后的原码
		//            00000000 00000000 00000000 00000001 正数的三码都一样
		System.out.println(~-2);//1

		//推导
		//1.先得到2的补码
		//	2的原码 ： 00000000 00000000 00000000 00000010
		//  2的补码 ： 00000000 00000000 00000000 00000010 正数三码合一
		//2.~2运算
		//            11111111 11111111 11111111 11111101 运算后的补码
		//3.运算后的原码
		//			  11111111 11111111 11111111 11111100 运算后的反码 = 补码 - 1 
		//            10000000 00000000 00000000 00000011 运算后的原码     
		System.out.println(~2);// -3

		// 2反码：     00000000 00000000 00000000 00000010
		// 3反码：     00000000 00000000 00000000 00000011
		// 运算：      00000000 00000000 00000000 00000011 运算后的反码
		// 运算后的原码 00000000 00000000 00000000 00000011
		System.out.println(2|3); //3

		// -5补码：
		//   原码：    10000000 00000000 00000000 00000101
		//   反码：    11111111 11111111 11111111 11111010
		//   补码：    11111111 11111111 11111111 11111011 补码 = 反码 + 1
		// ~运算：     00000000 00000000 00000000 00000100 运算后的补码
		// 运算后的原码 00000000 00000000 00000000 00000100 正数的三码合一
		System.out.println(~-5);//4

		// 13补码 = 原码
		//			  00000000 00000000 00000000 00001101
		// 7补码 = 原码
		//		      00000000 00000000 00000000 00000111
		//运算
		//			  00000000 00000000 00000000 00000101 运算后的补码和原码一样
		System.out.println(13&7);//5

		//5补码 = 原码
		//			  00000000 00000000 00000000 00000101			
		//4补码 = 原码
		//			  00000000 00000000 00000000 00000100
		//运算
		// 			  00000000 00000000 00000000 00000101 正数三码合一
		System.out.println(5|4);//5

		//1. -3补码
		//   -3原码： 10000000 00000000 00000000 00000011
		//   -3反码： 11111111 11111111 11111111 11111100
		//   -3补码： 11111111 11111111 11111111 11111101
		//2.  3补码： 00000000 00000000 00000000 00000011
		//运算
		//  	      11111111 11111111 11111111 11111110 补码
		//			  11111111 11111111 11111111 11111101 反码
		//			  10000000 00000000 00000000 00000010 原码				  
		System.out.println(-3^3);//-2
	}
}
```



# 位运算

##  按位与& ：两位全为1，结果为1

## 按位或| ： 两位有一位为1，结果为1

## 按位异或 ^： 两位一个为0，一个为1，结果为1（两位不一样为1，一样为0）

## 按位取反~ : 0 -> 1 , 1 -> 0 

## 还有3个位运算符>> 、 <<和>>>,运算规则：

### 1.算数右移 >>:低位溢出，符号位不变，并用符号位补溢出的高位

### 2. 算数左移<< : 符号位不变，低位补0

### 3. >>>逻辑右移也叫无符号右移，运算规则是：低位溢出，高位补0

### 4. 特别说明：没有<<<符号